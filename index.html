<html>
    <head>
        <link rel="shortcut icon" href="/favicon.ico">
        <style>
            @font-face {
                font-family: 'MS Gothic';
                src: url('/fonts/MS Gothic.ttf');
            }

            body {
                font-family: 'MS Gothic';
                margin: 0;
                background: #000000 url(https://img2.wikia.nocookie.net/__cb20140715140243/yume2kki/images/5/50/Wiki-background) top left repeat;
                overflow: hidden;
            }

            .content {
                background: rgba(0,0,0,0.8);
                padding-top: 0.1px;
            }

            .controls--container {
                position: absolute;
                width: 100%;
                z-index: 10;
            }

            .controls {
                position: absolute;
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-end;
                text-align: right;
                margin: 10px;
                margin-top: 20px;
                width: calc(100% - 40px);
                min-height: 64px;
                background: url(/images/ui/containerbg.png);
                border: 10px solid transparent;
                border-image: url(/images/ui/border.png);
                border-image-slice: 12;
                border-image-repeat: repeat;
                pointer-events: none;
            }

            .controls.visible {
                pointer-events: all !important;
            }

            .control {
                display: flex;
                align-items: center;
            }

            .graph {
                width: 100%;
                height: 100%;
            }

            .footer {
                position: absolute;
                padding: 8px;
                top: calc(100% - 36px);
                text-align: right;
                height: 26px;
                width: calc(100% - 16px);
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
            }

            label {
                font-size: 18px;
                color: #ded9df;
                margin-left: 16px;
            }

            button {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-image: url(/images/ui/containerbg.png);
            }

            input[type='text'], select, .slider {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
            }

            .slider {
                -webkit-appearance: none;
                appearance: none;
                width: 128px;
                height: 2px;
                padding: 0 4px;
                outline: none;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
                cursor: pointer;
            }

            .slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
                cursor: pointer;
            }

            .autocomplete-suggestions {
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background: #403842;
                overflow: auto;
            }

            .autocomplete-suggestion {
                padding: 2px 5px;
                white-space: nowrap;
                overflow: hidden;
            }

            .autocomplete-selected {
                background: #817084;
            }
            .autocomplete-suggestions strong {
                font-weight: normal;
                color: #ffea56;
            }

            .autocomplete-group {
                padding: 2px 5px;
            }

            .autocomplete-group strong {
                display: block;
                border-bottom: 1px solid #000;
            }
        </style>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css" />
        <script src="/js/force-graph-modded.js"></script>
        <script src="//unpkg.com/d3-quadtree"></script>
        <script src="//unpkg.com/d3-force"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.devbridge-autocomplete/1.4.10/jquery.autocomplete.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-localize/0.1.0/jquery.localize.min.js"></script>
        <script src="/js/conn-type.js"></script>
    </head>
    <body>
        <div class="content">
            <div class="controls--container">
                <div class="controls" style="opacity: 0;">
                    <div class="control">
                        <label data-localize="lang.name">Language:</label>
                        <select name="language" class="js--lang">
                            <option data-localize="lang.values.english" value="en" selected>English</option>
                            <option data-localize="lang.values.japanese" value="ja">Japanese</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="displayMode.name">Display Mode:</label>
                        <select name="displayMode" class="js--display-mode">
                            <option data-localize="displayMode.values.vertical" value="0" selected>Vertical</option>
                            <option data-localize="displayMode.values.horizontal" value="1">Horizontal</option>
                            <option data-localize="displayMode.values.radialIn" value="2">Inward</option>
                            <option data-localize="displayMode.values.radialOut" value="3">Outward</option>
                            <option data-localize="displayMode.values.free" value="4">Free</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="connMode.name">Connection Mode:</label>
                        <select name="connMode" class="js--conn-mode">
                            <option data-localize="connMode.values.oneWay" value="0" selected>One-Way)/option>
                            <option data-localize="connMode.values.twoWay" value="1">Two-Way</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="labelMode.name">Label Display:</label>
                        <select name="labelMode" class="js--label-mode">
                            <option data-localize="labelMode.values.never" value="0">Never</option>
                            <option data-localize="labelMode.values.hover" value="1" selected>On Hover</option>
                            <option data-localize="labelMode.values.select" value="2">On Select</option>
                            <option data-localize="labelMode.values.always" value="3">Always</option>
                        </select>
                    </div>
                    <div class="control">
                        <label data-localize="sizeDiff.name">Size Difference:</label>
                        <input type="range" min="1" max="10" value="1" step="0.5" class="js--size-diff slider" />
                    </div>
                    <div class="control js--stack-size--container">
                        <label data-localize="stackSize.name">Stack Threshold:</label>
                        <input type="range" min="5" max="100" value="20" step="1" class="js--stack-size slider" />
                    </div>
                    <div class="control">
                        <label data-localize="origin.name">Origin:</label>
                        <input name="startWorld" type="text" class="js--world-input js--start-world" />
                        <label data-localize="destination.name">Destination:</label>
                        <input name="endWorld" type="text" class="js--world-input js--end-world" />
                        <button data-localize="reset" class="js--reset">Reset</button>
                    </div>
                </div>
            </div>
            <div id="graph" class="graph"></div>
            <div data-localize="footer" class="footer"></div>
            <script>
                const isMobile = (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera);
                
                $(document).keydown(function (event) {
                    if (event.which === 16)
                        isShift = true;
                    else if (event.which === 17)
                        isCtrl = true;
                });

                $(document).keyup(function (event) {
                    if (event.which === 16)
                        isShift = false;
                    else if (event.which === 17)
                        isCtrl = false;
                });

                let isShift = false;
                let isCtrl = false;

                $.fn.extend({
                    animateCss: function (animation, duration, endCallback) {
                        const animationEnd = "webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend";
                        $(this).removeClass($(this).data("animateCss")).trigger("webkitAnimationEnd");
                        if (!duration)
                            duration = 250;
                        $(this).css({
                            "-webkit-animation-duration": duration + "ms",
                            "animation-duration": duration + "ms"
                        });
                        const classes = "animated " + animation;
                        $(this).data("animateCss", classes);

                        $(this).addClass(classes).one(animationEnd, function () {
                            $(this).off(animationEnd);
                            $(this).css({
                                "-webkit-animation-duration": "initial",
                                "animation-duration": "initial"
                            });
                            if (endCallback)
                                endCallback.apply(this);
                            $(this).removeClass(classes);
                        });

                        return this;
                    }
                });

                CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                    if (width < 2 * radius) radius = width / 2;
                    if (height < 2 * radius) radius = height / 2;
                    this.moveTo(x + radius, y);
                    this.arcTo(x + width, y, x + width, y + height, radius);
                    this.arcTo(x + width, y + height, x, y + height, radius);
                    this.arcTo(x, y + height, x, y, radius);
                    this.arcTo(x, y, x + width, y, radius);
                    return this;
                };

                CanvasRenderingContext2D.prototype.emoji = function (x, y, scale, emoji) {
                    this.beginPath();
                    
                    switch (emoji) {
                        case "⛔":
                        case "🚫":
                            this.arc(x + 3.125 * scale, y - 2.1 * scale, 3.3 * scale, 0, 2 * Math.PI);
                            break;
                        case "🔒":
                        case "🔐":
                            const isCondition = emoji === "🔐";
                            this.roundRect(x - 0.21 * scale, y - 2.45 * scale, 5.4 * scale, 3.7 * scale, 0.5 * scale);
                            if (isCondition)
                                this.arc(x + 4.875 * scale, y - 3 * scale, 1.6 * scale, 0, 2 * Math.PI);
                            this.moveTo(x + 0.175 * scale, y - 2.445 * scale);
                            this.arc(x + 2.5 * scale, y - 3.1 * scale, 2.325 * scale, Math.PI, 0);
                            this.lineTo(x + 4.825 * scale, y - 2.445 * scale);
                            if (isCondition) {
                                this.moveTo(x + 5.65 * scale, y - 1.5825 * scale);
                                this.lineTo(x + 5.65 * scale, y + 0.525 * scale);
                                this.lineTo(x + 4.85 * scale, y + 1.2375 * scale);
                                this.lineTo(x + 4.85 * scale, y - 1.5825 * scale);
                            }
                            break;
                        case "🔑":
                            this.moveTo(x + 3.75 * scale, y - 2.9 * scale);
                            this.lineTo(x + 6.5 * scale, y - 0.15 * scale);
                            this.lineTo(x + 6.5 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 1.2 * scale);
                            this.lineTo(x + 4.85 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y + 0.6 * scale);
                            this.lineTo(x + 4.15 * scale, y);
                            this.lineTo(x + 3.5 * scale, y);
                            this.lineTo(x + 3.5 * scale, y - 0.6 * scale);
                            this.lineTo(x + 3.1 * scale, y - 0.6 * scale);
                            this.lineTo(x + 2.4 * scale, y - 1.4 * scale);
                            this.arc(x + 1.85 * scale, y - 3.35 * scale, 2.1 * scale, 0.4 * Math.PI, 2.4 * Math.PI)
                            break;
                        case "🚩":
                            this.moveTo(x - 0.05 * scale, y + 1.25 * scale);
                            this.lineTo(x - 0.05 * scale, y - 4.25 * scale);
                            this.arc(x + 0.475 * scale, y - 4.75 * scale, 0.725 * scale, 0.75 * Math.PI, 2.05 * Math.PI);
                            this.lineTo(x + 5.9 * scale, y - 3.1 * scale);
                            this.arc(x + 5.675 * scale, y - 2.775 * scale, 0.375 * scale, 1.5 * Math.PI, 0.4 * Math.PI);
                            this.lineTo(x + 1 * scale, y - 0.8 * scale);
                            this.lineTo(x + 1 * scale, y + 1.25 * scale);
                            break;
                        case "↩️":
                            this.rect(x - 0.2 * scale, y - 5.425 * scale, 6.675 * scale, 6.675 * scale);
                            break;
                        case "✨":
                            this.moveTo(x + 1.5 * scale, y - 2.64 * scale);
                            this.bezierCurveTo(x + 3.6 * scale, y - 2.15 * scale, x + 3.35 * scale, y - 4.7 * scale, x + 3.35 * scale, y - 4.7 * scale);
                            this.arc(x + 3.85 * scale, y - 4.8 * scale, 0.5 * scale, Math.PI, 2 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 2.25 * scale, x + 6 * scale, y - 2.5 * scale, x + 6 * scale, y - 2.5 * scale);
                            this.arc(x + 6 * scale, y - 2 * scale, 0.5 * scale, 1.5 * Math.PI, 0.5 * Math.PI);
                            this.bezierCurveTo(x + 4.05 * scale, y - 1.75 * scale, x + 4.35 * scale, y + 0.7 * scale, x + 4.35 * scale, y + 0.7 * scale);
                            this.arc(x + 3.85 * scale, y + 0.8 * scale, 0.5 * scale, 0, Math.PI);
                            this.bezierCurveTo(x + 3.6 * scale, y - 1.75 * scale, x + 1.5 * scale, y - 1.5 * scale, x + 1.5 * scale, y - 1.5 * scale);
                            this.roundRect(x - 0.2 * scale, y - 3.35 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 0.6 * scale, y - 4.4 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            this.rect(x + 2.6 * scale, y - 1.2 * scale, 0.4 * scale, 0.4 * scale);
                            this.roundRect(x + 0.85 * scale, y - 0.85 * scale, 2.65 * scale, scale, 0.5 * scale);
                            this.roundRect(x + 1.65 * scale, y - 1.9 * scale, 1.05 * scale, 3.1 * scale, 0.5 * scale);
                            break;
                        case "🍀":
                            this.arc(x + 1 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 2.125 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.1 * scale, y - 4.4 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.225 * scale, y - 3.325 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 0.875 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 1.975 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 3.125 * scale, y + 0.7 * scale, 0.575 * scale, 0, 2 * Math.PI);
                            this.arc(x + 5.375 * scale, y - 1.375 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.arc(x + 4.225 * scale, y - 0.275 * scale, 1.1 * scale, 0, 2 * Math.PI);
                            this.lineTo(x + 3.5 * scale, y + 0.85 * scale);
                            this.lineTo(x + 2 * scale, y + 0.85 * scale);
                            this.rect(x + 1.5 * scale, y - 3.5 * scale, 3.25 * scale, 4 * scale);
                            break;
                    }
                    this.closePath();
                };

                function hueToRGB(h) {
                    let s = 1, v = 1, r, g, b, i, f, p, q, t;
                    i = Math.floor(h * 6);
                    f = h * 6 - i;
                    p = v * (1 - s);
                    q = v * (1 - f * s);
                    t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return "rgb(" + Math.round(r * 255) + "," + Math.round(g * 255) + "," + Math.round(b * 255) + ")";
                }

                let worldData;

                function loadOrInitConfig() {
                    try {
                        if (!window.localStorage.hasOwnProperty("config")) {
                            window.localStorage.setItem("config", JSON.stringify(config));
                        } else {
                            const savedConfig = JSON.parse(window.localStorage.getItem("config"));
                            const configKeys = Object.keys(savedConfig);
                            for (let c in configKeys) {
                                const key = configKeys[c];
                                if (config.hasOwnProperty(key)) {
                                    const value = savedConfig[key];
                                    config[key] = value;
                                    switch (key) {
                                        case "lang":
                                            $(".js--lang").val(value);
                                            break;
                                        case "displayMode":
                                            $(".js--display-mode").val(value);
                                            if (parseInt(value) >= 2)
                                                $(".js--stack-size--container").css("display", "none");
                                            break;
                                        case "connMode":
                                            $(".js--conn-mode").val(value);
                                            break;
                                        case "labelMode":
                                            $(".js--label-mode").val(value);
                                            break;
                                        case "sizeDiff":
                                            $(".js--size-diff").val(value);
                                            break;
                                        case "stackSize":
                                            $(".js--stack-size").val(value);
                                            break;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                    }
                }

                function updateConfig() {
                    try {
                        window.localStorage.config = JSON.stringify(config);
                    } catch (error) {
                    }
                }

                function updateControlsContainerHeight() {
                    $(".controls--container").css("height", $(".controls").outerHeight() + "px");
                }

                function loadWorldData(update, callback) {
                    $.get("/worlds" + (update ? "?update=true" : ""), function (data) {
                        callback(data);
                    });
                }

                let graph;
                
                let selectedWorldId;

                let localizedConns;
                
                let effectsJP;

                let config = {
                    lang: "en",
                    displayMode: 0,
                    connMode: 0,
                    labelMode: 1,
                    sizeDiff: 1,
                    stackSize: 20
                };

                function initGraph(displayMode, paths) {

                    let visibleWorldIds;
                    
                    const links = [];

                    const oneWayLinks = [];

                    let lastOneWayLinkKey;

                    let dashOffset = 0;

                    const addedLinks = [];

                    const worldScales = {};

                    const dagIgnore = {};

                    _.each(worldData, w => {
                        worldScales[w.id] = 1 + (Math.round((w.size - minSize) / (maxSize - minSize) * 10 * (config.sizeDiff - 1)) / 10);
                    });

                    if (paths) {
                        visibleWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                        const pathScores = [];
                        let minPathDepth = paths[0].length - 2;
                        let maxPathDepth;
                        let depthDiff;
                        let maxPathScore;
                        for (let pi in paths) {
                            const path = paths[pi];
                            if (path.length - 2 > minPathDepth * 2) {
                                let visibleWorldIdRemovalCandidates = _.uniq(_.flatten(paths.slice(pi)).map(p => p.id));
                                paths = paths.slice(0, pi);
                                let requiredWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                                _.remove(visibleWorldIdRemovalCandidates, w => requiredWorldIds.indexOf(w) > -1);
                                _.remove(visibleWorldIds, w => visibleWorldIdRemovalCandidates.indexOf(w) > -1);
                                break;
                            }
                            pathScores[pi] = parseInt(pi) + 3 * ((path.length - 2) - minPathDepth);
                        }
                        maxPathDepth = paths[paths.length - 1].length;
                        depthDiff = maxPathDepth - minPathDepth;
                        maxPathScore = ((paths.length - 1) + (3 * depthDiff)) * (depthDiff > 0 ? 1 : 2) || 1;
                        if (paths.length === 1 && paths[0][0].connType & ConnType.INACCESSIBLE)
                            pathScores[0] = maxPathScore;
                        for (let p in paths) {
                            const path = paths[p];
                            for (let w = 1; w < path.length; w++) {
                                const sourceId = path[w - 1].id;
                                const targetId = path[w].id;
                                const linkId = `${sourceId}_${targetId}`;
                                if (addedLinks.indexOf(linkId) === -1) {
                                    dagIgnore[sourceId] = [];
                                    const link = {
                                        key: linkId,
                                        source: sourceId,
                                        target: targetId,
                                        sourceScale: worldScales[sourceId],
                                        targetScale: worldScales[targetId],
                                        connType: path[w - 1].connType,
                                        typeParams: path[w - 1].typeParams,
                                        icons: [],
                                        hidden: false,
                                        defaultColor: hueToRGB(0.6666 - ((pathScores[p] / maxPathScore) * 0.6666)),
                                        connTypeCheck: path[w - 1].connType ? 'replace' : undefined
                                    };
                                    links.push(link);
                                    addedLinks.push(linkId);
                                    if (path[w - 1].connType & ConnType.ONE_WAY)
                                        oneWayLinks.push(link);
                                }
                            }
                        }
                    } else {
                        visibleWorldIds = Object.keys(worldData).map(id => parseInt(id));

                        const maxDepth =  _.max(worldData.map(w => w.depth));

                        for (let w in visibleWorldIds) {
                            const world = worldData[visibleWorldIds[w]];
                            const connections = world.connections;
                            const dagIgnoreIds = dagIgnore[world.id] = [];
                            for (let c in connections) {
                                const conn = connections[c];
                                const connWorld = worldData[conn.targetId];
                                let hidden = false;
                                if (conn.type & ConnType.NO_ENTRY)
                                    hidden = true;
                                else if (world.depth >= connWorld.depth) {
                                    const sameDepth = world.depth === connWorld.depth;
                                    const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                    hidden = (!sameDepth && !reverseConn.length) || (reverseConn.length && !(reverseConn[0].type & ConnType.NO_ENTRY) && (!sameDepth || (!(conn.type & ConnType.ONE_WAY) && world.id > connWorld.id)));
                                    dagIgnoreIds.push(connWorld.id);
                                }
                                if (hidden)
                                    dagIgnoreIds.push(connWorld.id);
                                const link = {
                                    key: `${world.id}_${connWorld.id}`,
                                    source: world.id,
                                    target: connWorld.id,
                                    sourceScale: worldScales[world.id],
                                    targetScale: worldScales[connWorld.id],
                                    connType: conn.type,
                                    typeParams: conn.typeParams,
                                    icons: [],
                                    hidden: hidden,
                                    defaultColor: hueToRGB(0.6666 - ((world.depth / (maxDepth - 1)) * 0.6666)),
                                    connTypeCheck: conn.type ? hidden ? 'after' : 'replace' : undefined
                                };
                                links.push(link);
                                if (!hidden && conn.type & ConnType.ONE_WAY)
                                    oneWayLinks.push(link);
                            }
                        }
                    }
                    oneWayLinks.length && (lastOneWayLinkKey = oneWayLinks[oneWayLinks.length - 1].key);

                    links.forEach(l => {
                        const icons = l.icons;
                        const connType = l.connType;
                        if (connType & ConnType.INACCESSIBLE)
                            icons.push(getConnTypeIcon(ConnType.INACCESSIBLE));
                        else {
                            if (connType & ConnType.ONE_WAY)
                                icons.push(getConnTypeIcon(ConnType.ONE_WAY));
                            else if (connType & ConnType.NO_ENTRY)
                                icons.push(getConnTypeIcon(ConnType.NO_ENTRY));
                            if (connType & ConnType.UNLOCK)
                                icons.push(getConnTypeIcon(ConnType.UNLOCK));
                            else if (connType & ConnType.LOCKED)
                                icons.push(getConnTypeIcon(ConnType.LOCKED));
                            else if (connType & ConnType.LOCKED_CONDITION)
                                icons.push(getConnTypeIcon(ConnType.LOCKED_CONDITION, l.typeParams[ConnType.LOCKED_CONDITION]));
                            if (connType & ConnType.DEAD_END)
                                icons.push(getConnTypeIcon(ConnType.DEAD_END));
                            else if (connType & ConnType.ISOLATED)
                                icons.push(getConnTypeIcon(ConnType.ISOLATED));
                            if (connType & ConnType.EFFECT)
                                icons.push(getConnTypeIcon(ConnType.EFFECT, l.typeParams[ConnType.EFFECT]));
                            if (connType & ConnType.CHANCE)
                                icons.push(getConnTypeIcon(ConnType.CHANCE, l.typeParams[ConnType.CHANCE]));
                        }
                    });

                    const images = (paths ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1) : worldData)
                        .map(d => {
                            const img = new Image();
                            img.id = d.id;
                            img.title = config.lang === "en" || !d.titleJP ? d.title : d.titleJP;
                            img.src = `./images/worlds/${d.filename}`;
                            return img;
                        });

                    const radius = 12;
                
                    const gData = {
                        nodes: images.map(img => {
                            const id = parseInt(img.id);
                            const scale = worldScales[id];
                            const ret = { id: id, img, isHover: false, scale: scale };
                            ret.globalDepth = worldData[id].depth;
                            ret.dagIgnore = dagIgnore[id];
                            ret.width = 16 * scale;
                            ret.height = 12 * scale;
                            return ret;
                        }),
                        links: links
                    };

                    let nodeDepths;

                    let depthDistances;

                    const elem = document.getElementById('graph');
                
                    graph = ForceGraph()(elem);
                    if (displayMode < 4) {
                        graph = graph
                            .dagMode(displayMode === 0 ? 'td' : displayMode === 1 ? 'lr' : displayMode === 2 ? 'radialin' : 'radialout')
                            .dagLevelDistance(displayMode < 2 ? 12 : 24 + radius * (config.sizeDiff + 1));
                    }
                    graph
                        .nodeCanvasObject(({ id, img, x, y, scale, width, height, isHover }, ctx, globalScale) => {
                            ctx.imageSmoothingEnabled = false;
                            ctx.drawImage(img, 0, 0, img.width, img.height, x - width / 2, y - height / 2, width, height);
                            if (config.labelMode === 3 || (config.labelMode === 1 && isHover) || (config.labelMode === 2 && id === selectedWorldId)) {
                                ctx.lineWidth = 0.25 * scale;
                                ctx.strokeStyle = "#000000";
                                ctx.fillStyle = "#ded9df";
                                ctx.font = (2 * scale) + "px 'MS Gothic'";
                                const world = worldData[id];
                                const worldName = config.lang === "en" || !world.titleJP ? world.title : world.titleJP;
                                let textLines = worldName.split(" ");
                                for (let l = 0; l < textLines.length; l++) {
                                    if (ctx.measureText(textLines[l]).width < width) {
                                        let mergeIndex = 0;
                                        for (let l2 = l + 1; l2 < textLines.length; l2++) {
                                            const mergedLine = textLines.slice(l, l2 + 1).join(" ");
                                            if (ctx.measureText(mergedLine).width < width) {
                                                mergeIndex = l2;
                                            } else
                                                break;
                                        }
                                        if (mergeIndex) {
                                            textLines = textLines.slice(0, l).concat([textLines.slice(l, mergeIndex + 1).join(" ")], textLines.slice(mergeIndex + 1));
                                        }
                                    } else if (textLines[l].indexOf("：") > -1)
                                        textLines = textLines.slice(0, l).concat(textLines[l].replace(/：/g, "： ").split(" ")).concat(textLines.slice(l + 1));
                                }
                                for (let l in textLines) {
                                    const textLine = textLines[l];
                                    const lineWidth = ctx.measureText(textLine).width;
                                    const lineX = x - lineWidth / 2;
                                    const lineY = (y + 0.5 * scale) - (textLines.length - 1) + l * 2 * scale;
                                    ctx.strokeText(textLine, lineX, lineY);
                                    ctx.fillText(textLine, lineX, lineY);
                                }
                            }
                            if (selectedWorldId == id) {
                                ctx.strokeStyle = '#f00';
                                ctx.lineWidth = 1 / globalScale;
                                ctx.strokeRect(x - width / 2, y - height / 2, width, height);
                            }
                            if (isHover && (isShift || isCtrl)) {
                                ctx.fillText("🔗", x + (width / 2) - 3.5, y - (height / 2) + 2.5);
                            }
                        })
                        .nodeVal(node => node.height)
                        .nodeLabel(node => node.img.title)
                        .nodesPerStack(config.stackSize)
                        .linkWidth(link => selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1)
                        .linkColor(link => link.hidden ? 'transparent' : selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor)
                        .linkCanvasObjectMode('connTypeCheck')
                        .linkCanvasObject((link, ctx, globalScale) => {
                            const hidden = link.hidden;
                            if (hidden && config.connMode === 0)
                                return;
                            const connType = link.connType;
                            if (!hidden) {
                                ctx.beginPath();
                                ctx.lineWidth = (selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1) / globalScale;
                                ctx.strokeStyle = selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor;
                                if (connType && connType & ConnType.ONE_WAY) {
                                    let currentDashOffset = dashOffset;
                                    if (link.key === lastOneWayLinkKey)
                                        dashOffset = dashOffset < 9.8 ? dashOffset + 0.2 : 0;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = currentDashOffset * -1;
                                }
                            }
                            const sourceX = link.source.x;
                            const sourceY = link.source.y;
                            const targetX = link.target.x;
                            const targetY = link.target.y;
                            if (!hidden) {
                                ctx.moveTo(sourceX, sourceY);
                                ctx.lineTo(targetX, targetY);
                                ctx.stroke();
                                ctx.closePath();
                            }
                            if (link.icons.length)
                                drawLinkIcons(link, ctx, globalScale);
                        })
                        .onNodeHover((node, prevNode) => {
                            elem.style.cursor = node ? 'pointer' : null;
                            if (node)
                                node.isHover = true;
                            if (prevNode)
                                prevNode.isHover = false;
                        })
                        .onNodeClick(node => {
                            if (isCtrl || isShift) {
                                const world = worldData[node.id];
                                window.open(config.lang === "en" || !world.titleJP
                                    ? 'https://yume2kki.fandom.com/wiki/' + world.title
                                    : ('https://wikiwiki.jp/yume2kki-t/' + (world.titleJP.indexOf("：") > -1 ? world.titleJP.slice(0, world.titleJP.indexOf("：")) : world.titleJP)),
                                    "_blank", isShift ? "width=" + window.outerWidth + ",height=" + window.outerHeight : "");
                            } else {
                                // Center/zoom on node
                                selectedWorldId = node && (!selectedWorldId || selectedWorldId !== node.id) ? node.id : null;
                                graph.centerAt(node.x, node.y, 1000);
                                graph.zoom(8, 1000);
                            }
                        })
                        .iconLabel(icon => {
                            return icon.text;   
                        })
                        .cooldownTime(Infinity)
                        // Deactivate existing forces
                        // Add collision and bounding box forces
                        .d3Force('collide', d3.forceCollide((node) => radius * worldScales[node.id]))
                        .d3Force('box', () => {
                            const SQUARE_HALF_SIDE = radius * 50;

                            gData.nodes.forEach(node => {
                                const x = node.x || 0, y = node.y || 0;

                                // bounce on box walls
                                if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx += 0.1 * (x > 0 ? -1 : 1); }
                                if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy += 0.1 * (y > 0 ? -1 : 1); }
                            });
                        })
                        .graphData(gData);
                }

                function getConnTypeIcon(connType, typeParams) {
                    const localizedConn = localizedConns[connType];
                    const char = getConnTypeChar(connType);
                    const name = localizedConn.name;
                    let description = localizedConn.description;
                    if (description) {
                        switch (connType) {
                            case ConnType.EFFECT:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : null;
                                break;
                            case ConnType.CHANCE:
                                description = typeParams && typeParams.params
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.params.replace('%', '％'))
                                    : '';
                                break;
                            case ConnType.LOCKED_CONDITION:
                                description = typeParams && ((config.lang === 'en' && typeParams.params) || (config.lang !== 'en' && typeParams.paramsJP))
                                    ? description.replace('{0}', config.lang === 'en' ? typeParams.params : typeParams.paramsJP)
                                    : '';
                                break;
                        }
                    }
                    return {
                        char: char,
                        text: name + (description ? (config.lang === 'en' ? ' - ' : '：') + description : '')
                    };
                }

                function getConnTypeChar(connType) {
                    let char;
                    switch (connType) {
                        case ConnType.ONE_WAY:
                            char = "➜";
                            break;
                        case ConnType.NO_ENTRY:
                            char = "⛔";
                            break;
                        case ConnType.UNLOCK:
                            char = "🔑";
                            break;
                        case ConnType.LOCKED:
                            char = "🔒";
                            break;
                        case ConnType.DEAD_END:
                            char = "🚩";
                            break;
                        case ConnType.ISOLATED:
                            char = "↩️";
                            break;
                        case ConnType.EFFECT:
                            char = "✨";
                            break;
                        case ConnType.CHANCE:
                            char = "🍀";
                            break;
                        case ConnType.LOCKED_CONDITION:
                            char = "🔐";
                            break;
                        case ConnType.INACCESSIBLE:
                            char = "🚫";
                            break;
                    }
                    return char;
                }

                function drawLinkIcons(link, ctx, globalScale) {
                    const sourceScale = link.sourceScale;
                    const targetScale = link.targetScale;
                    const connType = link.connType;
                    const icons = link.icons;
                    let sourceX = link.source.x;
                    let sourceY = link.source.y;
                    let targetX = link.target.x;
                    let targetY = link.target.y;
                    let tempSourceX = sourceX;
                    let tempSourceY = sourceY;
                    let tempTargetX = targetX;
                    let tempTargetY = targetY;
                    /*ctx.save();
                    ctx.beginPath();
                    var style = ctx.strokeStyle;
                    var lwidth = ctx.lineWidth;
                    ctx.strokeStyle = "rgba(255, 0, 0, 1)";
                    ctx.lineWidth = 0.1;*/
                    let gapSize;
                    const scale = globalScale < 24 ? 1 : 24 / globalScale;
                    const isX = Math.abs(targetX - sourceX) >= Math.abs(targetY - sourceY);
                    if (isX) {
                        const addSourceCoord = (sourceX < targetX ? 8 : -8) * sourceScale;
                        const addTargetCoord = (targetX < sourceX ? 8 : -8) * targetScale;
                        sourceX += addSourceCoord;
                        sourceY = sourceY + (tempTargetY - tempSourceY)/(tempTargetX - tempSourceX) * addSourceCoord;
                        targetX += addTargetCoord;
                        targetY = targetY + (tempSourceY - tempTargetY)/(tempSourceX - tempTargetX) * addTargetCoord;
                        gapSize = Math.max(Math.min(((sourceX < targetX ? targetX - sourceX : sourceX - targetX) - 16 * scale) / icons.length - 1, 8 * scale), 0);
                    } else {
                        const addSourceCoord = (sourceY < targetY ? 6 : -6) * sourceScale;
                        const addTargetCoord = (targetY < sourceY ? 6 : -6) * targetScale;
                        sourceY += addSourceCoord;
                        sourceX = sourceX + (tempTargetX - tempSourceX)/(tempTargetY - tempSourceY) * addSourceCoord;
                        targetY += addTargetCoord;
                        targetX = targetX + (tempSourceX - tempTargetX)/(tempSourceY - tempTargetY) * addTargetCoord;
                        gapSize = Math.max(Math.min(((sourceY < targetY ? targetY - sourceY : sourceY - targetY) - 16 * scale) / icons.length - 1, 8 * scale), 0);
                    }
                    /*ctx.arc(sourceX, sourceY, 0.3, 0, 2 * Math.PI)
                    ctx.stroke();
                    ctx.closePath();
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(0, 0, 255, 1)";
                    ctx.arc(targetX, targetY, 0.3, 0, 2 * Math.PI)
                    ctx.stroke();
                    ctx.closePath();
                    ctx.restore();
                    ctx.strokeStyle = style;
                    ctx.lineWidth = lwidth;*/
                    ctx.fillStyle = "#fff";
                    ctx.font = (scale * 6) + "px 'MS Gothic'";
                    const textBaseX = (sourceX * 1.5 + targetX * 0.5) / 2;
                    const textBaseY = (sourceY * 1.5 + targetY * 0.5) / 2;
                    for (let e = 0; e < icons.length; e++) {
                        const emoji = icons[e].char;
                        let textX, textY;
                        const addCoord = gapSize * ((icons.length * -0.5) + e + 0.5); //e * gapSize;
                        if (isX) {
                            textX = (textBaseX + addCoord) - 3.5 * scale;
                            textY = textBaseY + (targetY - sourceY)/(targetX - sourceX) * addCoord;
                        } else {
                            textY = textBaseY + addCoord;
                            textX = (textBaseX + (targetX - sourceX)/(targetY - sourceY) * addCoord) - 3.5 * scale;
                        }
                        /*if (isX) {
                            textX = ((sourceX + 8 * scale) + addCoord) - 3.5 * scale;
                            textY = sourceY + (targetY - sourceY)/(targetX - sourceX) * addCoord;
                        } else {
                            textY = ((sourceY + 8 * scale) + addCoord)
                            textX = (sourceX + (targetX - sourceX)/(targetY - sourceY) * addCoord) - 3.5 * scale;;
                        }*/
                        if (e === 0 && connType & ConnType.ONE_WAY) {
                            ctx.beginPath();
                            ctx.setLineDash([0, 0]);
                            if (sourceX >= targetX) {
                                ctx.save();
                                ctx.scale(-1, 1);
                                textX += 7 * scale;
                                ctx.strokeStyle = "#000";
                                ctx.lineWidth = 0.2 * scale;
                                ctx.roundRect(-textX - 0.25 * scale, textY - 5.5 * scale, 6.5 * scale, 6.5 * scale, 0.5 * scale);
                                ctx.fill();
                                ctx.stroke();
                                ctx.fillStyle = "#000";
                                ctx.fillText(emoji, -textX, textY);
                                ctx.fillStyle = "#fff";
                                ctx.restore();
                            } else {
                                ctx.strokeStyle = "#000";
                                ctx.lineWidth = 0.2 * scale;
                                ctx.roundRect(textX - 0.25 * scale, textY - 5.5 * scale, 6.5 * scale, 6.5 * scale, 0.5 * scale);
                                ctx.fill();
                                ctx.stroke();
                                ctx.fillStyle = "#000";
                                ctx.fillText(emoji, textX, textY);
                                ctx.fillStyle = "#fff";
                            }
                            ctx.closePath();
                        } else
                            ctx.fillText(emoji, textX, textY);
                    }
                }

                function reloadGraph() {
                    const startVal = $(".js--start-world").val();
                    const endVal = $(".js--end-world").val();
                    const startWorld = startVal && worldNames.indexOf(startVal) > -1 ? worldsByName[startVal] : null;
                    const endWorld = endVal && worldNames.indexOf(endVal) > -1 ? worldsByName[endVal] : null;
                    const matchPaths = startWorld && endWorld && startWorld != endWorld
                        ? findPath(startWorld.id, endWorld.id, ConnType.NO_ENTRY | ConnType.DEAD_END | ConnType.ISOLATED)
                        : null;
                    if (graph)
                        graph._destructor();
                    initGraph(config.displayMode, matchPaths)
                }

                let mult = 1;

                function findPath(s, t, ignoreTypeFlags) {
                    const startTime = performance.now();

                    const checkedSourceNodes = [s];
                    const checkedTargetNodes = [t];

                    const source = worldData[s];
                    const target = worldData[t];

                    let matchPaths = [];

                    let sourcePaths = {};
                    let targetPaths = {};

                    let nextGenSourceWorlds = [source];
                    let nextGenTargetWorlds = [target];

                    let genIndex = 0;

                    sourcePaths[s] = [{ id: s, connType: null }];
                    targetPaths[t] = [{ id: t, connType: null }];
                  
                    while (genIndex <= 20) {
                        let sourceWorlds = nextGenSourceWorlds.slice(0);
                        let targetWorlds = nextGenTargetWorlds.slice(0);
                        nextGenSourceWorlds = [];
                        nextGenTargetWorlds = [];
                        for (let sw in sourceWorlds) {
                            const sourceWorld = sourceWorlds[sw];
                            const sourcePath = sourcePaths[sourceWorld.id];
                            //delete sourcePaths[sourceWorld.id];
                            const sourceConns = traverseConns(checkedSourceNodes, sourcePath, nextGenSourceWorlds, sourceWorld, ignoreTypeFlags, true);
                            $.extend(sourcePaths, sourceConns);
                        }
                        for (let tw in targetWorlds) {
                            const targetWorld = targetWorlds[tw];
                            const targetPath = targetPaths[targetWorld.id];
                            //delete targetPaths[targetWorld.id];
                            const targetConns = traverseConns(checkedTargetNodes, targetPath, nextGenTargetWorlds, targetWorld, ignoreTypeFlags, false);
                            $.extend(targetPaths, targetConns);
                        }
                        
                        genIndex++;

                        /*let checkedSourceIds = Object.keys(sourcePaths).map(id => parseInt(id));
                        let checkedTargetIds = Object.keys(targetPaths).map(id => parseInt(id));*/

                        $.grep(checkedSourceNodes, id => {
                            const ret = $.inArray(id, checkedTargetNodes) !== -1;
                            if (ret) {
                                let skip = false;

                                let sourcePath = _.cloneDeep(sourcePaths[id]);
                                let targetPath = _.cloneDeep(targetPaths[id]);

                                if (sourcePath[sourcePath.length - 1].id === id && targetPath[targetPath.length - 1].id === id) {
                                    sourcePath = sourcePath.slice(0, -1);
                                }

                                let loopWorldIds, sourcePathIds, targetPathIds;
                                while ((loopWorldIds = _.intersectionWith((sourcePathIds = sourcePath.map(sp => sp.id)), (targetPathIds = targetPath.map(tp => tp.id)), _.isEqual)).length) {
                                    //console.log("Loop found", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                    sourcePath = sourcePath.slice(0, sourcePathIds.indexOf(loopWorldIds[0]));
                                    targetPath = targetPath.slice(0, targetPathIds.indexOf(loopWorldIds[0]) + 1);
                                    //console.log("Loop fixed", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                }
                                
                                const matchPath = sourcePath.concat(targetPath.reverse());
                                for (let p in matchPaths) {
                                    for (let w = 1; w < matchPaths[p].length; w++) {
                                        const linkId = `${matchPaths[p][w - 1].id}_${matchPaths[p][w].id}`;
                                        for (let m = 1; m < matchPath.length; m++) {
                                            const matchLinkId = `${matchPath[m - 1].id}_${matchPath[m].id}`;
                                            if (linkId === matchLinkId) {
                                                skip = true;
                                                break;
                                            }
                                        }
                                        if (skip)
                                            break;
                                    }
                                    if (skip)
                                        break;
                                }
                                if (skip)
                                    return false;
                                _.remove(nextGenSourceWorlds, w => w.id === id);
                                _.remove(nextGenTargetWorlds, w => w.id === id);
                                matchPaths.push(matchPath);
                            }
                            return ret;
                        });
                    }

                    const endTime = performance.now();

                    console.log("Found", matchPaths.length, "matching path(s) in", Math.round((endTime - startTime) * 10) / 10, "ms");

                    if (!matchPaths.length) {
                        if (ignoreTypeFlags & ConnType.DEAD_END)
                            ignoreTypeFlags ^= (ConnType.DEAD_END | ConnType.ISOLATED);
                        else
                            ignoreTypeFlags = 0;
                        if (ignoreTypeFlags)
                            return findPath(s, t, ignoreTypeFlags);
                        else {
                            matchPaths = [ [ { id: s, connType: ConnType.INACCESSIBLE }, { id: t, connType: null } ] ];
                            return matchPaths;
                        }
                    } else {
                        if ((!(ignoreTypeFlags & ConnType.LOCKED) && _.every(matchPaths, mp => mp.filter(p => p.connType && p.connType & (ConnType.LOCKED | ConnType.LOCKED_CONDITION).length)))) {
                            const additionalPaths = findPath(s, t, (ignoreTypeFlags = ignoreTypeFlags | ConnType.LOCKED | ConnType.LOCKED_CONDITION));
                            if (additionalPaths.length && !(additionalPaths[0][0].connType & ConnType.INACCESSIBLE)) {
                                for (let ap in additionalPaths)
                                    matchPaths.push(additionalPaths[ap]);
                            }
                        }
                        matchPaths = _.sortBy(matchPaths, [ 'length' ]);
                        if (matchPaths.length > 5)
                            matchPaths = matchPaths.slice(0, 5);
                    }

                    return matchPaths;
                }

                function traverseConns(checkedNodes, path, nextGenWorlds, world, ignoreTypeFlags, isSource) {
                    const ret = {};
                    const conns = world.connections;
                    for (let c in conns) {
                        let connType = conns[c].type;
                        if (isSource && connType & ignoreTypeFlags)
                            continue;
                        const connWorld = worldData[conns[c].targetId];
                        const id = connWorld.id;
                        if (checkedNodes.indexOf(id) === -1) {
                            // If checking from target
                            if (isSource) {
                                path[path.length - 1].connType = connType;
                                path[path.length - 1].typeParams = conns[c].typeParams;
                                connType = null;
                            } else {
                                const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                let reverseConnType = 0;
                                if (reverseConn.length)
                                    reverseConnType = reverseConn[0].type;
                                else {
                                    if (connType & ConnType.ONE_WAY)
                                        reverseConnType |= ConnType.DEAD_END;
                                    else if (connType & ConnType.NO_ENTRY)
                                        reverseConnType |= ConnType.ONE_WAY;
                                    if (connType & ConnType.LOCKED)
                                        reverseConnType |= ConnType.UNLOCK;
                                    else if (connType & ConnType.UNLOCK)
                                        reverseConnType |= ConnType.LOCKED;
                                    if (connType & ConnType.DEAD_END)
                                        reverseConnType |= ConnType.ISOLATED;
                                    else if (connType & ConnType.ISOLATED)
                                        reverseConnType |= ConnType.DEAD_END;
                                }
                                connType = reverseConnType;
                                if (connType & ignoreTypeFlags)
                                    continue;
                            }
                            const connPath = path.slice(0);
                            connPath.push({
                                id: id,
                                connType: connType
                            });
                            ret[id] = connPath;
                            checkedNodes.push(id);
                            nextGenWorlds.push(worldData[id]);
                        }
                    }
                    return ret;
                }

                function findConnectionAnomalies() {
                    const connData = {};
                    worldData.forEach(w => {
                        connData[w.id] = [];
                        worldData[w.id].connections.map(c => worldData[c.targetId]).forEach(c => {
                            connData[w.id].push(c.id);
                        });
                    }); 
                    Object.keys(connData).forEach(id => {
                        let connIds = connData[id].slice(0);
                        connIds.forEach(c => {
                            const index = connData[c].indexOf(parseInt(id));
                            if (index > -1) {
                                connData[id].splice(connData[id].indexOf(c), 1);
                                connData[c].splice(index, 1);
                            }
                        });
                    });
                    Object.keys(connData).forEach(id => {
                        if (connData[id].length) {
                            connData[id].forEach(c => {
                                console.log(worldData[c].title, "is missing a connection to", worldData[id].title);
                            });
                        }
                    });
                }

                function initLocalization() {
                    const isEn = config.lang === "en";

                    $("[data-localize]").localize("ui", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data, defaultCallback) {
                            data.footer = data.footer.replace("{VERSION}", "1.0.2");
                            localizedConns = data.conn;
                            defaultCallback(data);
                        }
                    });

                    $.localize("conn", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data) {
                            localizedConns = data;
                        }
                    });

                    if (!effectsJP) {
                        $.localize("effect", {
                            language: 'ja',
                            pathPrefix: "/lang",
                            callback: function (data) {
                                effectsJP = data;
                            }
                        });
                    }

                    $(".js--world-input").each(function() {
                        const val = $(this).val();
                        if (val && worldNames.indexOf(val) > -1) {
                            const world = worldsByName[worldNames[worldNames.indexOf(val)]];
                            $(this).val(isEn || !world.titleJP ? world.title : world.titleJP);
                        }
                    });

                    worldsByName = isEn ? _.keyBy(worldData, w => w.title) : _.keyBy(worldData, w => w.titleJP || w.title);

                    worldNames = Object.keys(worldsByName);

                    $(".js--world-input").autocomplete("destroy").autocomplete({
                        lookup: worldNames,
                        onSelect: reloadGraph
                    });
                }

                let worldsByName, worldNames, minSize, maxSize, nodes;

                $(document).ready(function () {
                    if (isMobile) {
                        $(".controls").addClass("visible").css("opacity", 1);
                    } else {
                        $(".controls--container").mouseenter(function () {
                            $(".controls").addClass("visible").css("opacity", 1).animateCss("fadeInDown", 250);
                        }).mouseleave(function () {
                            $(".controls").removeClass("visible").animateCss("fadeOutUp", 250, function () {
                                if (!$(this).hasClass("visible"))
                                    $(this).css("opacity", 0);
                            });
                        });
                        updateControlsContainerHeight();
                        $(window).resize(updateControlsContainerHeight);
                    }

                    $(window).blur(function() {
                        isShift = false;
                        isCtrl = false;
                    });

                    loadWorldData(false, function (data) {
                        worldData = data;

                        $(".js--lang").change(function() {
                            config.lang = $(this).val();
                            updateConfig();
                            initLocalization();
                            reloadGraph();
                        });

                        $(".js--display-mode").change(function() {
                            config.displayMode = parseInt($(this).val());
                            updateConfig();
                            reloadGraph();
                            $(".js--stack-size--container").css("display", config.displayMode < 2 ? "flex" : "none");
                        });

                        $(".js--conn-mode").change(function() {
                            config.connMode = parseInt($(this).val());
                            updateConfig();
                        });

                        $(".js--label-mode").change(function() {
                            config.labelMode = parseInt($(this).val());
                            updateConfig();
                        });

                        $(".js--size-diff").change(function() {
                            config.sizeDiff = parseFloat($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--stack-size").change(function() {
                            config.stackSize = parseInt($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--reset").click(function() {
                            $(".js--world-input").val("");
                            reloadGraph();
                        });

                        loadOrInitConfig();

                        initLocalization();

                        for (let d in Object.keys(worldData)) {
                            const world = worldData[d];
                            world.id = parseInt(d);
                            world.connections.forEach(conn => {
                                const effectParams = conn.typeParams[ConnType.EFFECT];
                                if (effectParams) {
                                    effectParams.paramsJP = effectParams.params.split(',').map(e => effectsJP[e]).join('」か「');
                                    effectParams.params = effectParams.params.replace(/,/g, ', ');
                                }
                            });
                        }

                        const worldSizes = worldData.map(w => w.size); 

                        minSize = _.min(worldSizes);
                        maxSize = _.max(worldSizes);

                        reloadGraph();
                    });
                });
            </script>
        </div>
    </body>
</html>