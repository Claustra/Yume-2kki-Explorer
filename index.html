<html>
    <head>
        <link rel="shortcut icon" href="/favicon.ico">
        <style>
            @font-face {
                font-family: 'MS Gothic';
                src: url('/fonts/MS Gothic.ttf');
            }

            body {
                font-family: 'MS Gothic';
                margin: 0;
                background: #000000 url(https://img2.wikia.nocookie.net/__cb20140715140243/yume2kki/images/5/50/Wiki-background) top left repeat;
                overflow: hidden;
            }

            .content {
                background: rgba(0,0,0,0.8);
                padding-top: 0.1px;
            }

            .controls {
                position: absolute;
                display: flex;
                flex-wrap: wrap;
                justify-content: flex-end;
                z-index: 10;
                text-align: right;
                margin: 10px;
                margin-top: 20px;
                width: calc(100% - 40px);
                min-height: 64px;
                background: url(/images/ui/containerbg.png);
                border: 10px solid transparent;
                border-image: url(/images/ui/border.png);
                border-image-slice: 12;
                border-image-repeat: repeat;
            }

            .control {
                display: flex;
                align-items: center;
            }

            .graph {
                width: 100%;
                height: 100%;
            }

            .footer {
                position: absolute;
                padding: 8px;
                top: calc(100% - 36px);
                text-align: right;
                height: 26px;
                width: calc(100% - 16px);
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
            }

            label {
                font-size: 18px;
                color: #ded9df;
                margin-left: 16px;
            }

            button {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-image: url(/images/ui/containerbg.png);
            }

            input[type='text'], select, .slider {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
            }

            .slider {
                -webkit-appearance: none;
                appearance: none;
                width: 128px;
                height: 2px;
                padding: 0 4px;
                outline: none;
            }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
                cursor: pointer;
            }

            .slider::-moz-range-thumb {
                width: 25px;
                height: 25px;
                width: 24px;
                height: 38px;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
                cursor: pointer;
            }

            .autocomplete-suggestions {
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background: #403842;
                overflow: auto;
            }

            .autocomplete-suggestion {
                padding: 2px 5px;
                white-space: nowrap;
                overflow: hidden;
            }

            .autocomplete-selected {
                background: #817084;
            }
            .autocomplete-suggestions strong {
                font-weight: normal;
                color: #ffea56;
            }

            .autocomplete-group {
                padding: 2px 5px;
            }

            .autocomplete-group strong {
                display: block;
                border-bottom: 1px solid #000;
            }
        </style>
        <script src="/js/force-graph-modded.js"></script>
        <script src="//unpkg.com/d3-quadtree"></script>
        <script src="//unpkg.com/d3-force"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.devbridge-autocomplete/1.4.10/jquery.autocomplete.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-localize/0.1.0/jquery.localize.min.js"></script>
        <script src="/js/conn-type.js"></script>
    </head>
    <body>
        <div class="content">
            <div class="controls">
                <div class="control">
                    <label data-localize="lang.name">Language:</label>
                    <select name="language" class="js--lang">
                        <option data-localize="lang.values.english" value="en" selected>English</option>
                        <option data-localize="lang.values.japanese" value="ja">Japanese</option>
                    </select>
                </div>
                <div class="control">
                    <label data-localize="displayMode.name">Display Mode:</label>
                    <select name="displayMode" class="js--display-mode">
                        <option data-localize="displayMode.values.hierarchical" value="0" selected>Hierarchical (One-Way)</option>
                        <option data-localize="displayMode.values.free" value="1">Free (Two-Way)</option>
                    </select>
                </div>
                <div class="control">
                    <label data-localize="labelMode.name">Label Display:</label>
                    <select name="labelMode" class="js--label-mode">
                        <option data-localize="labelMode.values.never" value="0">Never</option>
                        <option data-localize="labelMode.values.hover" value="1" selected>On Hover</option>
                        <option data-localize="labelMode.values.always" value="2">Always</option>
                    </select>
                </div>
                <div class="control">
                    <label data-localize="sizeDiff.name">Size Difference:</label>
                    <input type="range" min="1" max="10" value="1" step="0.5" class="js--size-diff slider" />
                </div>
                <div class="control">
                    <label data-localize="origin.name">Origin:</label>
                    <input name="startWorld" type="text" class="js--world-input js--start-world" />
                </div>
                <div class="control">
                    <label data-localize="destination.name">Destination:</label>
                    <input name="endWorld" type="text" class="js--world-input js--end-world" />
                </div>
                <div class="control">
                    <button data-localize="reset" class="js--reset">Reset</button>
                </div>
            </div>
            <div id="graph" class="graph"></div>
            <div data-localize="footer" class="footer"></div>
            <script>
                let worldData;

                function loadOrInitConfig() {
                    try {
                        if (!window.localStorage.hasOwnProperty("config")) {
                            window.localStorage.setItem("config", JSON.stringify(config));
                        } else {
                            const savedConfig = JSON.parse(window.localStorage.getItem("config"));
                            const configKeys = Object.keys(savedConfig);
                            for (let c in configKeys) {
                                const key = configKeys[c];
                                if (config.hasOwnProperty(key)) {
                                    const value = savedConfig[key];
                                    config[key] = value;
                                    switch (key) {
                                        case "lang":
                                            $(".js--lang").val(value);
                                            break;
                                        case "displayMode":
                                            $(".js--display-mode").val(value);
                                            break;
                                        case "labelMode":
                                            $(".js--label-mode").val(value);
                                            break;
                                        case "sizeDiff":
                                            $(".js--size-diff").val(value);
                                            break;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                    }
                }

                function updateConfig() {
                    try {
                        window.localStorage.config = JSON.stringify(config);
                    } catch (error) {
                    }
                }

                function loadWorldData(update, callback) {
                    $.get("/worlds" + (update ? "?update=true" : ""), function (data) {
                        callback(data);
                    });
                }

                CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                    if (width < 2 * radius) radius = width / 2;
                    if (height < 2 * radius) radius = height / 2;
                    this.beginPath();
                    this.moveTo(x + radius, y);
                    this.arcTo(x + width, y, x + width, y + height, radius);
                    this.arcTo(x + width, y + height, x, y + height, radius);
                    this.arcTo(x, y + height, x, y, radius);
                    this.arcTo(x, y, x + width, y, radius);
                    this.closePath();
                    return this;
                }

                function hueToRGB(h) {
                    let s = 1, v = 1, r, g, b, i, f, p, q, t;
                    i = Math.floor(h * 6);
                    f = h * 6 - i;
                    p = v * (1 - s);
                    q = v * (1 - f * s);
                    t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return "rgb(" + Math.round(r * 255) + "," + Math.round(g * 255) + "," + Math.round(b * 255) + ")";
                }

                let graph;
                
                let selectedWorldId;

                let config = {
                    lang: "en",
                    displayMode: 0,
                    labelMode: 1,
                    sizeDiff: 1
                };

                function initGraph(paths) {

                    let visibleWorldIds;
                    
                    const links = [];

                    const oneWayLinks = [];

                    let lastOneWayLinkKey;

                    let dashOffset = 0;

                    const addedLinks = [];

                    if (paths) {
                        visibleWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                        const pathScores = [];
                        let minPathDepth = paths[0].length - 2;
                        let maxPathDepth;
                        let depthDiff;
                        let maxPathScore;
                        for (let pi in paths) {
                            const path = paths[pi];
                            if (path.length - 2 > minPathDepth * 2) {
                                let visibleWorldIdRemovalCandidates = _.uniq(_.flatten(paths.slice(pi)).map(p => p.id));
                                paths = paths.slice(0, pi);
                                let requiredWorldIds = _.uniq(_.flatten(paths).map(p => p.id));
                                _.remove(visibleWorldIdRemovalCandidates, w => requiredWorldIds.indexOf(w) > -1);
                                _.remove(visibleWorldIds, w => visibleWorldIdRemovalCandidates.indexOf(w) > -1);
                                break;
                            }
                            pathScores[pi] = parseInt(pi) + 3 * ((path.length - 2) - minPathDepth);
                        }
                        maxPathDepth = paths[paths.length - 1].length;
                        depthDiff = maxPathDepth - minPathDepth;
                        maxPathScore = ((paths.length - 1) + (3 * depthDiff)) * (depthDiff > 0 ? 1 : 2) || 1;
                        if (paths.length === 1 && paths[0][0].connType & ConnType.INACCESSIBLE)
                            pathScores[0] = maxPathScore;
                        for (let p in paths) {
                            const path = paths[p];
                            for (let w = 1; w < path.length; w++) {
                                const sourceId = path[w - 1].id;
                                const targetId = path[w].id;
                                const linkId = `${sourceId}_${targetId}`;
                                if (addedLinks.indexOf(linkId) === -1) {
                                    const link = {
                                        key: linkId,
                                        source: sourceId,
                                        target: targetId,
                                        connType: path[w - 1].connType,
                                        defaultColor: hueToRGB(0.6666 - ((pathScores[p] / maxPathScore) * 0.6666)),
                                        connTypeCheck: path[w - 1].connType ? 'replace' : undefined
                                    };
                                    links.push(link);
                                    addedLinks.push(linkId);
                                    if (path[w - 1].connType & ConnType.ONE_WAY)
                                        oneWayLinks.push(link);
                                }
                            }
                        }
                    } else {
                        visibleWorldIds = Object.keys(worldData).map(id => parseInt(id));

                        const maxDepth =  _.max(worldData.map(w => w.depth));

                        for (let w in visibleWorldIds) {
                            const world = worldData[visibleWorldIds[w]];
                            const connections = world.connections;
                            for (let c in connections) {
                                const conn = connections[c];
                                if (conn.type & ConnType.NO_ENTRY)
                                    continue;
                                const connWorld = worldData[conn.targetId];
                                if (config.displayMode === 1 || world.depth < connWorld.depth || (world.depth == connWorld.depth && world.id < connWorld.id)) {
                                    const link = {
                                        key: `${world.id}_${connWorld.id}`,
                                        source: world.id,
                                        target: connWorld.id,
                                        connType: conn.type,
                                        defaultColor: hueToRGB(0.6666 - ((world.depth / (maxDepth - 1)) * 0.6666)),
                                        connTypeCheck: conn.type ? 'replace' : undefined
                                    };
                                    links.push(link);
                                    if (conn.type & ConnType.ONE_WAY)
                                        oneWayLinks.push(link);
                                }
                            }
                        }
                        oneWayLinks.length && (lastOneWayLinkKey = oneWayLinks[oneWayLinks.length - 1].key);
                    }

                    const images = (paths ? worldData.filter(w => visibleWorldIds.indexOf(w.id) > -1) : worldData)
                        .map(d => {
                            const img = new Image();
                            img.id = d.id;
                            img.title = config.lang === "en" || !d.titleJP ? d.title : d.titleJP;
                            img.src = `./images/worlds/${d.filename}`;
                            return img;
                        });
                    
                    const worldScales = {};

                    _.each(worldData, w => {
                        worldScales[w.id] = 1 + (Math.round((w.size - minSize) / (maxSize - minSize) * 10 * (config.sizeDiff - 1)) / 10);
                    });

                    const radius = 12;
                
                    const gData = {
                        nodes: images.map(img => {
                            const ret = { id: parseInt(img.id), img, showLabel: false };
                            ret.width = 16 * worldScales[ret.id];
                            ret.height = 12 * worldScales[ret.id];
                            return ret;
                        }),
                        links: links
                    };

                    let nodeDepths;

                    let depthDistances;

                    const elem = document.getElementById('graph');
                
                    graph = ForceGraph()(elem);
                    if (config.displayMode === 0) {
                        graph = graph
                            .dagMode('td')
                            .dagLevelDistance(24 + radius * (config.sizeDiff + 1))
                            /*.dagLevelDistance(function (depth) {
                                if (depthDistances)
                                    return depthDistances[depth];
                                 const dagDepths = graph.getDagDepths();
                                 const nodeIds = Object.keys(dagDepths);
                                 const getNodeDepth = (n) => dagDepths[n];
                                 const nodeIdsByDepth = _.groupBy(nodeIds, getNodeDepth);
                                 depthDistances = {};
                                 const getNodeHeight = (n) => radius * Math.round(worldScales[n] * 10) / 10;
                                 _.each(Object.keys(nodeIdsByDepth), d => depthDistances[d] = _.max(nodeIdsByDepth[d].map(getNodeHeight), getNodeHeight));
                                 console.log(nodeIdsByDepth, depthDistances)
                                 return depthDistances[depth];
                            })*/;
                    }
                    graph
                        .nodeCanvasObject(({ id, img, x, y, showLabel }, ctx) => {
                            const scale = worldScales[id];
                            const width = 16 * scale, height = 12 * scale;
                            ctx.drawImage(img, x - width / 2, y - height / 2, width, height);
                            if (config.labelMode === 2 || (config.labelMode === 1 && showLabel)) {
                                ctx.lineWidth = 0.25 * scale;
                                ctx.strokeStyle = "#000000";
                                ctx.fillStyle = "#ded9df";
                                ctx.font = (2 * scale) + "px 'MS Gothic'";
                                const world = worldData[id];
                                const worldName = config.lang === "en" || !world.titleJP ? world.title : world.titleJP;
                                let textLines = worldName.split(" ");
                                for (let l = 0; l < textLines.length; l++) {
                                    if (ctx.measureText(textLines[l].width < width)) {
                                        let mergeIndex = 0;
                                        for (let l2 = l + 1; l2 < textLines.length; l2++) {
                                            const mergedLine = textLines.slice(l, l2 + 1).join(" ");
                                            if (ctx.measureText(mergedLine).width < width) {
                                                mergeIndex = l2;
                                            } else
                                                break;
                                        }
                                        if (mergeIndex) {
                                            textLines = textLines.slice(0, l).concat([textLines.slice(l, mergeIndex + 1).join(" ")], textLines.slice(mergeIndex + 1));
                                        }
                                    }
                                }
                                for (let l in textLines) {
                                    const textLine = textLines[l];
                                    const lineWidth = ctx.measureText(textLine).width;
                                    const lineX = x - lineWidth / 2;
                                    const lineY = (y + 0.5 * scale) - (textLines.length - 1) + l * 2 * scale;
                                    ctx.strokeText(textLine, lineX, lineY);
                                    ctx.fillText(textLine, lineX, lineY);
                                }
                            }
                            if (selectedWorldId == id) {
                                ctx.strokeStyle = '#f00';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(x - width / 2, y - height / 2, width, height);
                            }
                        })
                        .linkWidth(link => selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1)
                        .linkColor(link => selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor)
                        .linkCanvasObjectMode('connTypeCheck')
                        .linkCanvasObject((link, ctx, globalScale) => {
                            const sourceScale = worldScales[link.source.id || link.source];
                            const targetScale = worldScales[link.target.id || link.target];
                            const connType = link.connType;
                            ctx.beginPath();
                            ctx.lineWidth = (selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1) / globalScale;
                            ctx.strokeStyle = selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor;
                            const emojis = [];
                            if (connType) {
                                if (connType & ConnType.ONE_WAY)  {
                                    let currentDashOffset = dashOffset;
                                    if (link.key === lastOneWayLinkKey)
                                        dashOffset = dashOffset < 9.8 ? dashOffset + 0.2 : 0;
                                    ctx.setLineDash([5, 5]);
                                    ctx.lineDashOffset = currentDashOffset * -1;
                                    emojis.push("➜");
                                } else if (connType & ConnType.NO_ENTRY)
                                    emojis.push("⛔");
                                if (connType & ConnType.LOCKED)
                                    emojis.push("🔒")
                                else if (connType & ConnType.UNLOCK)
                                    emojis.push("🔑");
                                else if (connType & ConnType.LOCKED_CONDITION)
                                    emojis.push("🔐");
                                if (connType & ConnType.DEAD_END)
                                    emojis.push("🚩");
                                else if (connType & ConnType.ISOLATED)
                                    emojis.push("↩️");
                                if (connType & ConnType.EFFECT)
                                    emojis.push("✨");
                                if (connType & ConnType.CHANCE)
                                    emojis.push("🍀");
                                if (connType & ConnType.INACCESSIBLE)
                                    emojis.push("🚫");
                            }
                            let sourceX = link.source.x;
                            let sourceY = link.source.y;
                            let targetX = link.target.x;
                            let targetY = link.target.y;
                            let tempSourceX = sourceX;
                            let tempSourceY = sourceY;
                            let tempTargetX = targetX;
                            let tempTargetY = targetY;
                            const isX = Math.abs(targetX - sourceX) >= Math.abs(targetY - sourceY);
                            ctx.moveTo(sourceX, sourceY);
                            ctx.lineTo(targetX, targetY);
                            if (isX) {
                                const addSourceCoord = (sourceX < targetX ? 8 : -8) * sourceScale;
                                const addTargetCoord = (targetX < sourceX ? 8 : -8) * targetScale;
                                sourceX += addSourceCoord;
                                sourceY = sourceY + (tempTargetY - tempSourceY)/(tempTargetX - tempSourceX) * addSourceCoord;
                                targetX += addTargetCoord;
                                targetY = targetY + (tempSourceY - tempTargetY)/(tempSourceX - tempTargetX) * addTargetCoord;
                            } else {
                                const addSourceCoord = (sourceY < targetY ? 6 : -6) * sourceScale;
                                const addTargetCoord = (targetY < sourceY ? 6 : -6) * targetScale;
                                sourceY += addSourceCoord;
                                sourceX = sourceX + (tempTargetX - tempSourceX)/(tempTargetY - tempSourceY) * addSourceCoord;
                                targetY += addTargetCoord;
                                targetX = targetX + (tempSourceX - tempTargetX)/(tempSourceY - tempTargetY) * addTargetCoord;
                            }
                            ctx.stroke();
                            ctx.closePath();
                            if (emojis.length) {
                                ctx.imageSmoothingEnabled = false;
                                ctx.fillStyle = "#fff";
                                ctx.font = (globalScale < 24 ? 6 : 6 * (24 / globalScale)) + "px 'MS Gothic'";
                                const scale = globalScale < 24 ? 1 : 24 / globalScale;
                                const textBaseX = (sourceX * 1.5 + targetX * 0.5) / 2;
                                const textBaseY = (sourceY * 1.5 + targetY * 0.5) / 2;
                                for (let e = 0; e < emojis.length; e++) {
                                    const emoji = emojis[e];
                                    let textX, textY;
                                    const addCoord = 8 * ((emojis.length * -0.5) + e + 0.5);
                                    if (isX) {
                                        textX = (textBaseX + addCoord) - 3.5 * scale;
                                        textY = textBaseY + (targetY - sourceY)/(targetX - sourceX) * addCoord;
                                    } else {
                                        textY = textBaseY + addCoord;
                                        textX = (textBaseX + (targetX - sourceX)/(targetY - sourceY) * addCoord) - 3.5 * scale;
                                    }
                                    if (e === 0 && connType & ConnType.ONE_WAY) {
                                        ctx.beginPath();
                                        ctx.setLineDash([0, 0]);
                                        if (sourceX >= targetX) {
                                            ctx.save();
                                            ctx.scale(-1, 1);
                                            textX += 7 * scale;
                                            ctx.strokeStyle = "#000";
                                            ctx.lineWidth = 0.2 * scale;
                                            ctx.roundRect(-textX - 0.25 * scale, textY - 5.5 * scale, 6.5 * scale, 6.5 * scale, 0.5 * scale);
                                            ctx.fill();
                                            ctx.stroke();
                                            ctx.fillStyle = "#000";
                                            ctx.fillText(emoji, -textX, textY);
                                            ctx.fillStyle = "#fff";
                                            ctx.restore();
                                        } else {
                                            ctx.strokeStyle = "#000";
                                            ctx.lineWidth = 0.2 * scale;
                                            ctx.roundRect(textX - 0.25 * scale, textY - 5.5 * scale, 6.5 * scale, 6.5 * scale, 0.5 * scale);
                                            ctx.fill();
                                            ctx.stroke();
                                            ctx.fillStyle = "#000";
                                            ctx.fillText(emoji, textX, textY);
                                            ctx.fillStyle = "#fff";
                                        }
                                        ctx.closePath();
                                    } else
                                        ctx.fillText(emoji, textX, textY);
                                }
                            }
                            
                        })
                        .onNodeHover((node, prevNode) => {
                            elem.style.cursor = node ? 'pointer' : null;
                            if (config.labelMode === 1) {
                                if (node)
                                    node.showLabel = true;
                                if (prevNode)
                                    prevNode.showLabel = false;
                            }
                        })
                        .onNodeClick(node => {
                            // Center/zoom on node
                            selectedWorldId = node && (!selectedWorldId || selectedWorldId !== node.id) ? node.id : null;
                            graph.centerAt(node.x, node.y, 1000);
                            graph.zoom(8, 1000);
                        })
                        .cooldownTime(Infinity)
                        // Deactivate existing forces
                        // Add collision and bounding box forces
                        .d3Force('collide', d3.forceCollide((node) => radius * worldScales[node.id]))
                        .d3Force('box', () => {
                            const SQUARE_HALF_SIDE = radius * 50;

                            gData.nodes.forEach(node => {
                                const x = node.x || 0, y = node.y || 0;

                                // bounce on box walls
                                if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx += 0.1 * (x > 0 ? -1 : 1); }
                                if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy += 0.1 * (y > 0 ? -1 : 1); }
                            });
                        })
                        .graphData(gData);
                }

                function reloadGraph() {
                    const startVal = $(".js--start-world").val();
                    const endVal = $(".js--end-world").val();
                    const startWorld = startVal && worldNames.indexOf(startVal) > -1 ? worldsByName[startVal] : null;
                    const endWorld = endVal && worldNames.indexOf(endVal) > -1 ? worldsByName[endVal] : null;
                    const matchPaths = startWorld && endWorld && startWorld != endWorld
                        ? findPath(startWorld.id, endWorld.id, ConnType.NO_ENTRY | ConnType.DEAD_END | ConnType.ISOLATED)
                        : null;
                    $(".js--display-mode").prop("disabled", matchPaths || false);
                    initGraph(matchPaths)
                }

                let mult = 1;

                function findPath(s, t, ignoreTypeFlags) {
                    const startTime = performance.now();

                    const checkedSourceNodes = [s];
                    const checkedTargetNodes = [t];

                    const source = worldData[s];
                    const target = worldData[t];

                    let matchPaths = [];

                    let sourcePaths = {};
                    let targetPaths = {};

                    let nextGenSourceWorlds = [source];
                    let nextGenTargetWorlds = [target];

                    let genIndex = 0;

                    sourcePaths[s] = [{ id: s, connType: null }];
                    targetPaths[t] = [{ id: t, connType: null }];
                  
                    while (genIndex <= 20) {
                        let sourceWorlds = nextGenSourceWorlds.slice(0);
                        let targetWorlds = nextGenTargetWorlds.slice(0);
                        nextGenSourceWorlds = [];
                        nextGenTargetWorlds = [];
                        for (let sw in sourceWorlds) {
                            const sourceWorld = sourceWorlds[sw];
                            const sourcePath = sourcePaths[sourceWorld.id];
                            //delete sourcePaths[sourceWorld.id];
                            const sourceConns = traverseConns(checkedSourceNodes, sourcePath, nextGenSourceWorlds, sourceWorld, ignoreTypeFlags, true);
                            $.extend(sourcePaths, sourceConns);
                        }
                        for (let tw in targetWorlds) {
                            const targetWorld = targetWorlds[tw];
                            const targetPath = targetPaths[targetWorld.id];
                            //delete targetPaths[targetWorld.id];
                            const targetConns = traverseConns(checkedTargetNodes, targetPath, nextGenTargetWorlds, targetWorld, ignoreTypeFlags, false);
                            $.extend(targetPaths, targetConns);
                        }
                        
                        genIndex++;

                        /*let checkedSourceIds = Object.keys(sourcePaths).map(id => parseInt(id));
                        let checkedTargetIds = Object.keys(targetPaths).map(id => parseInt(id));*/

                        $.grep(checkedSourceNodes, id => {
                            const ret = $.inArray(id, checkedTargetNodes) !== -1;
                            if (ret) {
                                let skip = false;

                                let sourcePath = _.cloneDeep(sourcePaths[id]);
                                let targetPath = _.cloneDeep(targetPaths[id]);

                                if (sourcePath[sourcePath.length - 1].id === id && targetPath[targetPath.length - 1].id === id) {
                                    sourcePath = sourcePath.slice(0, -1);
                                }

                                let loopWorldIds, sourcePathIds, targetPathIds;
                                while ((loopWorldIds = _.intersectionWith((sourcePathIds = sourcePath.map(sp => sp.id)), (targetPathIds = targetPath.map(tp => tp.id)), _.isEqual)).length) {
                                    //console.log("Loop found", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                    sourcePath = sourcePath.slice(0, sourcePathIds.indexOf(loopWorldIds[0]));
                                    targetPath = targetPath.slice(0, targetPathIds.indexOf(loopWorldIds[0]) + 1);
                                    //console.log("Loop fixed", worldData[loopWorldIds[0]].title, JSON.stringify(sourcePath.map(function(p) { return worldData[p].title})), JSON.stringify(targetPath.map(function(p) { return worldData[p].title})));
                                }
                                
                                const matchPath = sourcePath.concat(targetPath.reverse());
                                for (let p in matchPaths) {
                                    for (let w = 1; w < matchPaths[p].length; w++) {
                                        const linkId = `${matchPaths[p][w - 1].id}_${matchPaths[p][w].id}`;
                                        for (let m = 1; m < matchPath.length; m++) {
                                            const matchLinkId = `${matchPath[m - 1].id}_${matchPath[m].id}`;
                                            if (linkId === matchLinkId) {
                                                skip = true;
                                                break;
                                            }
                                        }
                                        if (skip)
                                            break;
                                    }
                                    if (skip)
                                        break;
                                }
                                if (skip)
                                    return false;
                                _.remove(nextGenSourceWorlds, w => w.id === id);
                                _.remove(nextGenTargetWorlds, w => w.id === id);
                                matchPaths.push(matchPath);
                            }
                            return ret;
                        });
                    }

                    const endTime = performance.now();

                    console.log("Found", matchPaths.length, "matching path(s) in", Math.round((endTime - startTime) * 10) / 10, "ms");

                    console.log(matchPaths)

                    if (!matchPaths.length) {
                        if (ignoreTypeFlags & ConnType.DEAD_END)
                            ignoreTypeFlags ^= (ConnType.DEAD_END | ConnType.ISOLATED);
                        else
                            ignoreTypeFlags = 0;
                        if (ignoreTypeFlags)
                            return findPath(s, t, ignoreTypeFlags);
                        else {
                            matchPaths = [ [ { id: s, connType: ConnType.INACCESSIBLE }, { id: t, connType: null } ] ];
                            return matchPaths;
                        }
                    } else {
                        if ((!(ignoreTypeFlags & ConnType.LOCKED) && _.every(matchPaths, mp => mp.filter(p => p.connType && p.connType & (ConnType.LOCKED | ConnType.LOCKED_CONDITION).length)))) {
                            const additionalPaths = findPath(s, t, (ignoreTypeFlags = ignoreTypeFlags | ConnType.LOCKED | ConnType.LOCKED_CONDITION));
                            if (additionalPaths.length && !(additionalPaths[0][0].connType & ConnType.INACCESSIBLE)) {
                                for (let ap in additionalPaths)
                                    matchPaths.push(additionalPaths[ap]);
                            }
                        }
                        matchPaths = _.sortBy(matchPaths, [ 'length' ]);
                        if (matchPaths.length > 5)
                            matchPaths = matchPaths.slice(0, 5);
                    }

                    return matchPaths;
                }

                function traverseConns(checkedNodes, path, nextGenWorlds, world, ignoreTypeFlags, isSource) {
                    const ret = {};
                    const conns = world.connections;
                    for (let c in conns) {
                        let connType = conns[c].type;
                        if (isSource && connType & ignoreTypeFlags)
                            continue;
                        const connWorld = worldData[conns[c].targetId];
                        const id = connWorld.id;
                        if (checkedNodes.indexOf(id) === -1) {
                            // If checking from target
                            if (isSource) {
                                path[path.length - 1].connType = connType;
                                connType = null;
                            } else {
                                const reverseConn = connWorld.connections.filter(c => c.targetId === world.id);
                                let reverseConnType = 0;
                                if (reverseConn.length)
                                    reverseConnType = reverseConn[0].type;
                                else {
                                    if (connType & ConnType.ONE_WAY)
                                        reverseConnType |= ConnType.DEAD_END;
                                    else if (connType & ConnType.NO_ENTRY)
                                        reverseConnType |= ConnType.ONE_WAY;
                                    if (connType & ConnType.LOCKED)
                                        reverseConnType |= ConnType.UNLOCK;
                                    else if (connType & ConnType.UNLOCK)
                                        reverseConnType |= ConnType.LOCKED;
                                    if (connType & ConnType.DEAD_END)
                                        reverseConnType |= ConnType.ISOLATED;
                                    else if (connType & ConnType.ISOLATED)
                                        reverseConnType |= ConnType.DEAD_END;
                                }
                                connType = reverseConnType;
                                if (connType & ignoreTypeFlags)
                                    continue;
                            }
                            const connPath = path.slice(0);
                            connPath.push({
                                id: id,
                                connType: connType
                            });
                            ret[id] = connPath;
                            checkedNodes.push(id);
                            nextGenWorlds.push(worldData[id]);
                        }
                    }
                    return ret;
                }

                function initLocalization() {
                    const isEn = config.lang === "en";

                    $("[data-localize]").localize("ui", {
                        language: config.lang,
                        pathPrefix: "/lang",
                        callback: function (data, defaultCallback) {
                            data.footer = data.footer.replace("{VERSION}", "0.7.1");
                            defaultCallback(data);
                        }
                    });

                    $(".js--world-input").each(function() {
                        const val = $(this).val();
                        if (val && worldNames.indexOf(val) > -1) {
                            const world = worldsByName[worldNames[worldNames.indexOf(val)]];
                            $(this).val(isEn || !world.titleJP ? world.title : world.titleJP);
                        }
                    });

                    worldsByName = isEn ? _.keyBy(worldData, w => w.title) : _.keyBy(worldData, w => w.titleJP || w.title);

                    worldNames = Object.keys(worldsByName);

                    $(".js--world-input").autocomplete("destroy").autocomplete({
                        lookup: worldNames,
                        onSelect: reloadGraph
                    });
                }

                let worldsByName, worldNames, minSize, maxSize, nodes;

                $(document).ready(function () {
                    loadWorldData(false, function (data) {
                        worldData = data;

                        for (let d in Object.keys(worldData))
                            worldData[d].id = parseInt(d);

                        const worldSizes = worldData.map(w => w.size); 

                        minSize = _.min(worldSizes);
                        maxSize = _.max(worldSizes);

                        $(".js--lang").change(function() {
                            config.lang = $(this).val();
                            updateConfig();
                            initLocalization();
                            reloadGraph();
                        });

                        $(".js--display-mode").change(function() {
                            config.displayMode = parseInt($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--label-mode").change(function() {
                            config.labelMode = parseInt($(this).val());
                            updateConfig();
                        });

                        $(".js--size-diff").change(function() {
                            config.sizeDiff = parseFloat($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--reset").click(function() {
                            $(".js--world-input").val("");
                            reloadGraph();
                        });

                        loadOrInitConfig();

                        initLocalization();

                        reloadGraph();
                    });
                });
            </script>
        </div>
    </body>
</html>