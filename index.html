<html>
    <head>
        <link rel="shortcut icon" href="/favicon.ico">
        <style>
            @font-face {
                font-family: 'MS Gothic';
                src: url('/fonts/MS Gothic.ttf');
            }

            body {
                font-family: 'MS Gothic';
                margin: 0;
                background: #000000 url(https://img2.wikia.nocookie.net/__cb20140715140243/yume2kki/images/5/50/Wiki-background) top left repeat;
                overflow: hidden;
            }

            .content {
                background: rgba(0,0,0,0.8);
                padding-top: 0.1px;
            }

            .controls {
                position: absolute;
                z-index: 10;
                text-align: right;
                margin: 10px;
                margin-top: 20px;
                width: calc(100% - 40px);
                height: 64px;
                background: url(/images/ui/containerbg.png);
                border: 10px solid transparent;
                border-image: url(/images/ui/border.png);
                border-image-slice: 12;
                border-image-repeat: repeat;
            }

            .graph {
                width: 100%;
                height: 100%;
            }

            .footer {
                position: absolute;
                padding: 8px;
                top: calc(100% - 36px);
                text-align: right;
                height: 26px;
                width: calc(100% - 16px);
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
            }

            label {
                font-size: 18px;
                color: #ded9df;
                margin-left: 16px;
            }

            button {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-image: url(/images/ui/containerbg.png);
            }

            input[type='text'], select {
                margin: 8px;
                padding: 4px;
                font-family: 'MS Gothic';
                font-size: 18px;
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background-color: #403842;
            }

            .autocomplete-suggestions {
                color: #ded9df;
                border: 6px solid transparent;
                border-image: url(/images/ui/border2.png) 4 round;
                background: #403842;
                overflow: auto;
            }

            .autocomplete-suggestion {
                padding: 2px 5px;
                white-space: nowrap;
                overflow: hidden;
            }

            .autocomplete-selected {
                background: #817084;
            }
            .autocomplete-suggestions strong {
                font-weight: normal;
                color: #ffea56;
            }

            .autocomplete-group {
                padding: 2px 5px;
            }

            .autocomplete-group strong {
                display: block;
                border-bottom: 1px solid #000;
            }
        </style>
        <!--<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>-->
        <script src="//unpkg.com/force-graph"></script>
        <script src="//unpkg.com/d3-quadtree"></script>
        <script src="//unpkg.com/d3-force"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.15/lodash.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.devbridge-autocomplete/1.4.10/jquery.autocomplete.min.js"></script>
    </head>
    <body>
        <div class="content">
            <div class="controls">
                <label>
                    Display Mode:
                    <select name="displayMode" class="js--display-mode">
                        <option value="0" selected>Hierarchical (One-Way)</option>
                        <option value="1">Free (Two-Way)</option>
                    </select>
                </label>
                <label>
                    Label Display:
                    <select name="labelMode" class="js--label-mode">
                        <option value="0">Never</option>
                        <option value="1" selected>On Hover</option>
                        <option value="2">Always</option>
                    </select>
                </label>
                <label>
                    Origin:
                    <input name="startWorld" type="text" class="js--world-input js--start-world" />
                </label>
                <label>
                    Destination:
                    <input name="endWorld" type="text" class="js--world-input js--end-world" />
                </label>
                <button class="js--reset">Reset</button>
            </div>
            <div id="graph" class="graph"></div>
            <div class="footer">
                Yume 2kki Explorer v0.3 by FlashfyreDev
            </div>
            <script>
                var worldData;

                function loadOrInitConfig() {
                    if (!window.localStorage.hasOwnProperty("config")) {
                        window.localStorage.setItem("config", JSON.stringify(config));
                    } else {
                        let savedConfig = JSON.parse(window.localStorage.getItem("config"));
                        let configKeys = Object.keys(savedConfig);
                        for (var c in configKeys) {
                            let key = configKeys[c];
                            if (config.hasOwnProperty(key)) {
                                let value = savedConfig[key];
                                config[key] = value;
                                switch (key) {
                                    case "displayMode":
                                        $(".js--display-mode").val(value);
                                        break;
                                    case "labelMode":
                                        $(".js--label-mode").val(value);
                                        break;
                                }
                            }
                        }
                    }
                }

                function updateConfig() {
                    window.localStorage.config = JSON.stringify(config);
                }

                function loadWorldData(update, callback) {
                    $.get("/worlds" + (update ? "?update=true" : ""), function (data) {
                        callback(data);
                    });
                }

                function hueToRGB(h) {
                    var s = 1, v = 1, r, g, b, i, f, p, q, t;
                    i = Math.floor(h * 6);
                    f = h * 6 - i;
                    p = v * (1 - s);
                    q = v * (1 - f * s);
                    t = v * (1 - (1 - f) * s);
                    switch (i % 6) {
                        case 0: r = v, g = t, b = p; break;
                        case 1: r = q, g = v, b = p; break;
                        case 2: r = p, g = v, b = t; break;
                        case 3: r = p, g = q, b = v; break;
                        case 4: r = t, g = p, b = v; break;
                        case 5: r = v, g = p, b = q; break;
                    }
                    return "rgb(" + Math.round(r * 255) + "," + Math.round(g * 255) + "," + Math.round(b * 255) + ")";
                }

                var graph;
                
                var selectedWorldId;

                var config = {
                    displayMode: 0,
                    labelMode: 1
                };

                function initGraph(paths) {

                    var visibleWorldIds;
                    
                    let links = [];

                    let addedLinks = [];

                    if (paths) {
                        visibleWorldIds = _.uniq(_.flatten(paths));

                        let pathScores = [];
                        var minPathDepth = paths[0].length;
                        var maxPathDepth;
                        var depthDiff;
                        var maxPathScore;
                        for (var p in paths) {
                            let path = paths[p];
                            if (path.length > minPathDepth * 2) {
                                paths = paths.slice(0, p);
                                break;
                            }
                            pathScores[p] = parseInt(p) + 3 * (path.length - minPathDepth);
                        }
                        maxPathDepth = paths[paths.length - 1].length;
                        depthDiff = maxPathDepth - minPathDepth;
                        maxPathScore = ((paths.length - 1) + (3 * depthDiff)) * (depthDiff > 0 ? 1 : 2) || 1;
                        for (var p in paths) {
                            let path = paths[p];
                            for (var w = 1; w < path.length; w++) {
                                let sourceId = path[w - 1];
                                let targetId = path[w];
                                let linkId = `${sourceId}_${targetId}`;
                                if (addedLinks.indexOf(linkId) === -1) {
                                    links.push({
                                        source: sourceId,
                                        target: targetId,
                                        defaultColor: hueToRGB(0.6666 - ((pathScores[p] / maxPathScore) * 0.6666))
                                    });
                                    addedLinks.push(linkId);
                                }
                            }
                        }
                    } else {
                        visibleWorldIds = _.map(Object.keys(worldData), function(id) {
                            return parseInt(id);
                        });

                        let maxDepth =  _.max(_.map(worldData, (w) => w.depth));

                        for (var w in visibleWorldIds) {
                            let world = worldData[visibleWorldIds[w]];
                            let connections = world.connections;
                            for (var c in connections) {
                                let conn = connections[c];
                                if (conn.type < 2) {
                                    let connWorld = worldData[conn.targetId];
                                    if (config.displayMode === 1 || world.depth < connWorld.depth || (world.depth == connWorld.depth && world.id < connWorld.id)) {
                                        links.push({
                                            source: world.id,
                                            target: connWorld.id,
                                            defaultColor: hueToRGB(0.6666 - ((world.depth / (maxDepth - 1)) * 0.6666))
                                        });
                                    }
                                }
                            }
                        }
                    }

                    let images = (paths ? _.filter(worldData, function(w) {
                            return visibleWorldIds.indexOf(w.id) > -1;
                        }) : worldData)
                        .map(d => {
                            const img = new Image();
                            img.id = d.id;
                            img.title = d.title;
                            img.src = `./images/worlds/${d.filename}`;
                            return img;
                        });

                    //console.log(links);
                
                    let gData = {
                        nodes: images.map((img) => ({ id: parseInt(img.id), img, showLabel: false })),
                        links: links
                    };

                    let elem = document.getElementById('graph');
                
                    graph = ForceGraph()(elem);
                    if (config.displayMode === 0) {
                        graph = graph
                            .dagMode('td')
                            .dagLevelDistance(50)
                    }
                    graph
                        .nodeRelSize(12)
                        .nodeCanvasObject(({ id, img, x, y, showLabel }, ctx) => {
                            const width = 16, height = 12;
                            ctx.drawImage(img, x - width / 2, y - height / 2, width, height);
                            if (config.labelMode === 2 || (config.labelMode === 1 && showLabel)) {
                                ctx.lineWidth = 0.25;
                                ctx.strokeStyle = "#000000";
                                ctx.fillStyle = "#ded9df";
                                ctx.font = "2px 'MS Gothic'";
                                let worldName = worldData[id].title;
                                let textLines = worldName.split(" ");
                                for (var l = 0; l < textLines.length; l++) {
                                    if (ctx.measureText(textLines[l].width < 16)) {
                                        var mergeIndex = 0;
                                        for (var l2 = l + 1; l2 < textLines.length; l2++) {
                                            let mergedLine = textLines.slice(l, l2 + 1).join(" ");
                                            if (ctx.measureText(mergedLine).width < 16) {
                                                mergeIndex = l2;
                                            } else
                                                break;
                                        }
                                        if (mergeIndex) {
                                            textLines = textLines.slice(0, l).concat([textLines.slice(l, mergeIndex + 1).join(" ")], textLines.slice(mergeIndex + 1));
                                        }
                                    }
                                }
                                for (var l in textLines) {
                                    let textLine = textLines[l];
                                    let lineWidth = ctx.measureText(textLine).width;
                                    let lineX = x - lineWidth / 2;
                                    let lineY = (y + 0.5) - (textLines.length - 1) + l * 2;
                                    ctx.strokeText(textLine, lineX, lineY);
                                    ctx.fillText(textLine, lineX, lineY);
                                }
                            }
                            if (selectedWorldId == id) {
                                ctx.strokeStyle = '#f00';
                                ctx.lineWidth = 1;
                                ctx.strokeRect(x - width / 2, y - height / 2, width, height);
                            }
                        })
                        .linkWidth(link => selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? 2 : 1)
                        .linkColor(link => {
                            return selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId) ? '#f00' : link.defaultColor;
                        })
                        /*.linkCanvasObject((link, ctx) => {
                            //ctx.setLineDash([5, 5]);
                            if (selectedWorldId && (link.source.id === selectedWorldId || link.target.id === selectedWorldId)) {
                                ctx.lineWidth = 2;
                                ctx.strokeStyle = '#f00';
                            } else {
                                ctx.lineWidth = 1;
                                ctx.strokeStyle = '#ccc';
                            }
                            ctx.moveTo(link.source.x, link.source.y);
                            ctx.lineTo(link.target.x, link.target.y);

                            ctx.stroke();
                        })*/
                        .onNodeHover((node, prevNode) => {
                            elem.style.cursor = node ? 'pointer' : null;
                            if (config.labelMode === 1) {
                                if (node)
                                    node.showLabel = true;
                                if (prevNode)
                                    prevNode.showLabel = false;
                            }
                        })
                        .onNodeClick(node => {
                            // Center/zoom on node
                            selectedWorldId = node && (!selectedWorldId || selectedWorldId !== node.id) ? node.id : null;
                            graph.centerAt(node.x, node.y, 1000);
                            graph.zoom(8, 2000);
                        })
                        // Add collision and bounding box forces
                        .d3Force('collide', d3.forceCollide(graph.nodeRelSize()))
                        .d3Force('box', () => {
                            const SQUARE_HALF_SIDE = graph.nodeRelSize() * 100 * 0.5;

                            gData.nodes.forEach(node => {
                                const x = node.x || 0, y = node.y || 0;

                                // bounce on box walls
                                if (Math.abs(x) > SQUARE_HALF_SIDE) { node.vx += 0.1 * (x > 0 ? -1 : 1); }
                                if (Math.abs(y) > SQUARE_HALF_SIDE) { node.vy += 0.1 * (y > 0 ? -1 : 1); }
                            });
                        })
                        .graphData(gData);
                }

                function reloadGraph() {
                    let startVal = $(".js--start-world").val();
                    let endVal = $(".js--end-world").val();
                    let startWorld = startVal && worldNames.indexOf(startVal) > -1 ? worldsByName[startVal] : null;
                    let endWorld = endVal && worldNames.indexOf(endVal) > -1 ? worldsByName[endVal] : null;
                    let matchPaths = startWorld && endWorld && startWorld != endWorld
                        ? findPath(startWorld.id, endWorld.id)
                        : null;
                    $(".js--display-mode").prop("disabled", matchPaths || false);
                    initGraph(matchPaths)
                }

                function findPath(s, t) {
                    let startTime = performance.now();

                    let checkedSourceNodes = [s];
                    let checkedTargetNodes = [t];

                    let source = worldData[s];
                    let target = worldData[t];

                    let matchPaths = [];

                    var sourcePaths = {};
                    var targetPaths = {};

                    var nextGenSourceWorlds = [source];
                    var nextGenTargetWorlds = [target];

                    var genIndex = 0;

                    sourcePaths[s] = [];
                    targetPaths[t] = [];
                  
                    while (genIndex <= 15) {
                        var sourceWorlds = nextGenSourceWorlds.slice(0);
                        var targetWorlds = nextGenTargetWorlds.slice(0);
                        nextGenSourceWorlds = [];
                        nextGenTargetWorlds = [];
                        for (var sw in sourceWorlds) {
                            let sourceWorld = sourceWorlds[sw];
                            let sourcePath = sourcePaths[sourceWorld.id];
                            //delete sourcePaths[sourceWorld.id];
                            let sourceConns = traverseConns(checkedSourceNodes, sourcePath, nextGenSourceWorlds, sourceWorld, true);
                            $.extend(sourcePaths, sourceConns);
                        }
                        for (var tw in targetWorlds) {
                            let targetWorld = targetWorlds[tw];
                            let targetPath = targetPaths[targetWorld.id];
                            //delete targetPaths[targetWorld.id];
                            let targetConns = traverseConns(checkedTargetNodes, targetPath, nextGenTargetWorlds, targetWorld, false);
                            $.extend(targetPaths, targetConns);
                        }
                        
                        genIndex++;

                        /*var checkedSourceIds = _.map(Object.keys(sourcePaths), function(id) {
                            return parseInt(id);
                        });
                        var checkedTargetIds = _.map(Object.keys(targetPaths), function(id) {
                            return parseInt(id);
                        });;*/

                        $.grep(checkedSourceNodes, function(id) {
                            let ret = $.inArray(id, checkedTargetNodes) !== -1;
                            if (ret) {
                                var skip = false;

                                var sourcePath = [s].concat(sourcePaths[id]);
                                var targetPath = [t].concat(targetPaths[id]);

                                if (sourcePath[sourcePath.length - 1] === id && targetPath[targetPath.length - 1] === id) {
                                    sourcePath = sourcePath.slice(0, -1);
                                }

                                var loopWorlds;
                                while ((loopWorlds = _.intersectionWith(sourcePath, targetPath, _.isEqual)).length) {
                                    //console.log("Loop found", worldData[loopWorlds[0]].title, JSON.stringify(_.map(sourcePath, function(p) { return worldData[p].title})), JSON.stringify(_.map(targetPath, function(p) { return worldData[p].title})));
                                    sourcePath = sourcePath.slice(0, sourcePath.indexOf(loopWorlds[0]));
                                    targetPath = targetPath.slice(0, targetPath.indexOf(loopWorlds[0]) + 1);
                                    //console.log("Loop fixed", worldData[loopWorlds[0]].title, JSON.stringify(_.map(sourcePath, function(p) { return worldData[p].title})), JSON.stringify(_.map(targetPath, function(p) { return worldData[p].title})));
                                }
                                let matchPath = sourcePath.concat(targetPath.reverse());
                                for (var p in matchPaths) {
                                    for (var w = 1; w < matchPaths[p].length; w++) {
                                        let linkId = `${matchPaths[p][w - 1]}_${matchPaths[p][w]}`;
                                        for (var m = 1; m < matchPath.length; m++) {
                                            let matchLinkId = `${matchPath[m - 1]}_${matchPath[m]}`;
                                            if (linkId === matchLinkId) {
                                                skip = true;
                                                break;
                                            }
                                        }
                                        if (skip)
                                            break;
                                    }
                                    if (skip)
                                        break;
                                }
                                if (skip)
                                    return false;
                                _.remove(nextGenSourceWorlds, function(w) {
                                    return w.id === id;
                                });
                                _.remove(nextGenTargetWorlds, function(w) {
                                    return w.id === id;
                                });
                                matchPaths.push(matchPath);
                            }
                            return ret;
                        });
                        if (matchPaths.length >= 3)
                            break;
                    }

                    var endTime = performance.now();

                    console.log("Found ", matchPaths.length, " matching paths in ", Math.round((endTime - startTime) * 10) / 10, "ms");

                    if (!matchPaths.length)
                        matchPaths = [ [ s ], [ t ] ];
                    else {
                        matchPaths = _.sortBy(matchPaths, [ 'length' ]);
                        if (matchPaths.length > 5)
                            matchPaths = matchPaths.slice(0, 5);
                    }

                    return matchPaths;
                }

                function traverseConns(checkedNodes, path, nextGenWorlds, world, isSource) {
                    let ret = {};
                    let conns = world.connections;
                    for (var c in conns) {
                        if (conns[c].type >= 3 || conns[c].type === (isSource ? 2 : 1))
                            continue;
                        let id = worldData[conns[c].targetId].id;
                        if (checkedNodes.indexOf(id) === -1) {
                            let connPath = path.slice(0);
                            connPath.push(id);
                            ret[id] = connPath;
                            checkedNodes.push(id);
                            nextGenWorlds.push(worldData[id]);
                        }
                    }
                    return ret;
                }

                $(document).ready(function () {
                    loadWorldData(false, function (data) {
                        worldData = data;

                        for (var d in Object.keys(worldData))
                            worldData[d].id = parseInt(d);

                        worldsByName = _.keyBy(worldData, w => w.title);

                        worldNames = Object.keys(worldsByName);

                        $(".js--display-mode").change(function() {
                            config.displayMode = parseInt($(this).val());
                            updateConfig();
                            reloadGraph();
                        });

                        $(".js--label-mode").change(function() {
                            config.labelMode = parseInt($(this).val());
                            updateConfig();
                        });

                        $(".js--world-input").autocomplete({
                            lookup: worldNames,
                            onSelect: reloadGraph
                        });

                        $(".js--reset").click(function() {
                            $(".js--world-input").val("");
                            reloadGraph();
                        });

                        loadOrInitConfig();

                        reloadGraph();
                    });
                });
            </script>
        </div>
    </body>
</html>